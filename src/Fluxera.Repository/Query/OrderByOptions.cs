namespace Fluxera.Repository.Query{	using System;	using System.Linq.Expressions;	using Fluxera.Utilities.Extensions;	internal sealed class OrderByOptions<T> : IOrderByOptions<T>		where T : class	{		private ThenByOptions<T>? thenByOptions;		public IOrderByExpression<T>? OrderByExpression { get; private set; }		public IOrderByExpression<T>[]? ThenByExpressions => this.thenByOptions?.ThenByExpressions.AsReadOnly() as IOrderByExpression<T>[];		public IThenByOptions<T> OrderBy(Expression<Func<T, object>> orderByExpression)		{			this.OrderByExpression = new OrderByExpression<T>(orderByExpression, false);			return this.thenByOptions ??= new ThenByOptions<T>();		}		public IThenByOptions<T> OrderByDescending(Expression<Func<T, object>> orderByExpression)		{			this.OrderByExpression = new OrderByExpression<T>(orderByExpression, true);			return this.thenByOptions ??= new ThenByOptions<T>();		}		/// <summary>		///     Used in compiling a unique key for a query.		/// </summary>		/// <returns>Unique key for a query.</returns>		public override string ToString()		{			string orderByExpressionString = this.OrderByExpression != null ? this.OrderByExpression.ToString() : "none";			string thenByOptionsString = this.thenByOptions != null ? this.thenByOptions.ToString() : "none";			return "(OrderBy: {0}, ThenBy: {1})".FormatInvariantWith(orderByExpressionString, thenByOptionsString);		}	}}