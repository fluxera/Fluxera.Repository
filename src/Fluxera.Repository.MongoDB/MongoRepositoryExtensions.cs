namespace Fluxera.Repository.MongoDB{	using Fluxera.Entity;	using Fluxera.Repository.Query;	using global::MongoDB.Driver;	internal static class MongoRepositoryExtensions	{		internal static IFindFluent<TAggregateRoot, TAggregateRoot> ApplyOptions<TAggregateRoot>(			this IFindFluent<TAggregateRoot, TAggregateRoot> find, IQueryOptions<TAggregateRoot>? options,			bool ignoreOrderBy = false)			where TAggregateRoot : AggregateRoot<TAggregateRoot>		{			if(options is null)			{				return find;			}			if(options.HasPagingOptions)			{				options.TryGetPagingOptions(out IPagingOptions<TAggregateRoot>? pagingOptions);				find = find.Skip(pagingOptions.Skip).Limit(pagingOptions.PageSize);			}			if(options.HasSkipTakeOptions)			{				options.TryGetSkipTakeOptions(out ISkipTakeOptions<TAggregateRoot>? skipTakeOptions);				if(skipTakeOptions.Skip.HasValue)				{					find = find.Skip(skipTakeOptions.Skip.Value);				}				if(skipTakeOptions.Take.HasValue)				{					find = find.Limit(skipTakeOptions.Take.Value);				}			}			if(!ignoreOrderBy)			{				options.TryGetOrderByOptions(out IOrderByOptions<TAggregateRoot>? orderByOptions);				IOrderByExpression<TAggregateRoot>? orderBy = orderByOptions?.OrderByExpression;				if(orderBy != null)				{					IOrderedFindFluent<TAggregateRoot, TAggregateRoot> orderedFind = orderBy.IsDescending						? find.SortByDescending(orderBy.SortExpression)						: find.SortBy(orderBy.SortExpression);					if(orderByOptions.ThenByExpressions != null)					{						foreach(IOrderByExpression<TAggregateRoot> thenBy in orderByOptions.ThenByExpressions)						{							orderedFind = thenBy.IsDescending								? orderedFind.ThenBy(thenBy.SortExpression)								: orderedFind.ThenByDescending(thenBy.SortExpression);						}					}					find = orderedFind;				}			}			return find;		}	}}